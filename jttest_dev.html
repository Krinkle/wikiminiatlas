<html>
<head>
  <title>Client-side tile rendering test</title>
  <script type="text/javascript" src="jquery-1.5.1.min.js"></script>
  <style>
    canvas {
      border: 1px solid black; 
    }
  </style>
</head>
<body>
  <h1>Client-side tile rendering test</h1>
  <!--<img src="http://6.www.toolserver.org/~dschwen/wma/tiles/mapnik/12/2898/tile_2898_660.png"/>-->
  <div style="display: inline-block; position: relative">
    <img src="http://6.www.toolserver.org/~dschwen/wma/tiles/mapnik/12/3488/tile_3488_19316.png"/>
    <div style="background-color: red; opacity: 0.5; position: absolute; width: 32px; height: 32px; top: 0; left: 0; pointer-events: none"></div>
  </div>

  <div style="display: inline-block; position: relative">
    <canvas width="128" height="128" id="tile"></canvas>
    <div id="hilight" style="background-color: red; display: none; position: absolute; width: 64px; height: 64px; pointer-events: none"></div>
  </div>
  <p>Bounding box: <span id="bbox"></span></p>
  <p>
    Click on the right square to zoom in. The red area area on the left square highlights the initial field of view on a prerendered tite at the currently maximum zoom level in WikiMiniAtlas. The area shown is north east of Washington Circle in Washington DC, USA. Raw map data is pulled from OpenStreetMap and rendered in your browser. Reload to zoom out.
  </p>
  <script>
    var canvas,c,w,h
      , bx1, by1, bx2, by2, bw, bh, d=[]
      , x=19316*4, y=3488*4, z=14
      //, x=19316, y=3488, z=12
      //, x=660, y=2898, z=12
      ;

    // top right: lindau
    //http://6.www.toolserver.org/~dschwen/wma/tiles/mapnik/12/2898/tile_2898_660.png
    // dupont circle DC
    //http://4.www.toolserver.org/~dschwen/wma/tiles/mapnik/12/3488/tile_3488_19316.png

    // draw the data
    function drawGeoJSON() {
      var i, j, k, g, s, o
        , style = {
          Polygon: [
            ['leisure',{park:1,cemetary:1,orchard:1,meadow:1,village_green:1,
              forrest:1,recreation_ground:1,dog_park:1,garden:1,pitch:1,stadium:1},
              [ { fillStyle: "rgb(200,224,200)" } ]
            ],
            ['amenity',{university:1},
              [ { lineWidth:0.5, strokeStyle: "rgb(240,225,183)" } ]
            ],
            ['amenity',{parking:1},
              [ { fillStyle: "rgb(240,235,193)" } ]
            ],
            ['building',{yes:1},
              [ { fillStyle: "rgb(200,200,200)" },
                { lineWidth: 1, strokeStyle: "rgb(127,127,127)" } ]
            ]
          ],
          LineString: [
            ['highway',{service:1,path:1,track:1},
              [ { lineWidth: 4, strokeStyle: "rgb(168,168,168)" },
                { lineWidth: 3, strokeStyle: "rgb(208,208,208)" } ]
            ],
            ['highway',{residential:1},
              [ { lineWidth: 4, strokeStyle: "rgb(200,200,200)" },
                { lineWidth: 3, strokeStyle: "rgb(255,255,255)" } ]
            ],
            ['highway',{secondary:1,primary:1,primary_link:1,secondary_link:1},
              [ { lineWidth: 6, strokeStyle: "rgb(171,158,137)" },
                { lineWidth: 5, strokeStyle: "rgb(255,250,115)" } ]
            ]
          ]
        };  
      c.lineWidth = 1.0;

      // TODO: handle coastlines properly!!
      c.fillStyle = 'rgb(250, 250, 208)';
      c.fillRect(0,0,128,128);

      for( s in style ) {
        for( o=0; o < style[s].length; o++ ) {
          c.beginPath();
          
          for(i =0; i<d.length; ++i ) {
            // check against shape type and tags
            if( d[i].geo.type != s || 
                !( style[s][o][0] in d[i].tags ) ||
                !( d[i].tags[style[s][o][0]] in style[s][o][1] ) ) continue;

            // quick hack for shape type
            if( s == 'Polygon' ) {
              g = d[i].geo.coordinates[0];
            } else {
              g = d[i].geo.coordinates;
            }

            // iterate over all nodes
            if( g.length > 0 ) {
              c.moveTo((g[0][0]-bx1)*128/bw,128-(g[0][1]-by1)*128/bh);
              for( j=1; j<g.length; ++j ) {
                c.lineTo((g[j][0]-bx1)*128/bw,128-(g[j][1]-by1)*128/bh);
              }
            }
          }

          // iterate over the style components
          g = style[s][o][2]
          for( i=0; i<g.length; i++ ) {
            for( j in g[i] ) { c[j] = g[i][j]; }
            if( 'strokeStyle' in g[i] ) {
              c.stroke();
            }
            if( 'fillStyle' in g[i] ) {
              c.fill();
            }
          }
        }
      }
    }

    // return path element at screen coordinates
    function pathAt(x,y) {
    }

    function gotData(data) {
      d = data;
      update();
    }

    function update() {
      bx1 = x*60.0/(1<<z);
      by1 = 90.0 - ( ((y+1.0)*60.0) / (1<<z) );
      bx2 = (x+1) * 60.0 / (1<<z);
      by2 = 90.0 - ( (y*60.0) / (1<<z) );
      bw = bx2-bx1;
      bh = by2-by1;

      $('#bbox').text(bx1+' '+by1+', '+bx2+' '+by2);
      if(bx1>180.0) bx1-=360;

      drawGeoJSON();
    }

    $(function(){
      canvas = $('#tile');
      w = canvas[0].width;
      h = canvas[0].height;
      c = canvas[0].getContext('2d');

      $.ajax({
        url: 'jsontile_dev.php?x='+x+'&y='+y+'&z='+z,
        dataType: 'json',
        success: gotData
      });

      canvas
        .click(function(e){
          z++;
          x = x*2 + Math.floor(e.offsetX/64);
          y = y*2 + Math.floor(e.offsetY/64);
          update();
        })
        .mouseenter(function(e){
          $('#hilight').fadeTo(200,0.5);
        })
        .mousemove(function(e){
          var x = Math.floor(e.offsetX/64)
            , y =  Math.floor(e.offsetY/64);
          $('#hilight').css({
            top: (y>0?64:0) + 'px',
            left: (x>0?64:0) + 'px'
          });
        })
        .mouseleave( function(e) {
          $('#hilight').fadeOut(200);
        });

    });
  </script>
</body>
</html>
